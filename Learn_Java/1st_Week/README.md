# 1주차
## 구조
파일 → 클래스 → 메서드 → 실행문
- 클래스 : 객체 지향 언어에서 프로그램을 개발하는 단위
- 메서드 : 수행할 작업을 나열한 코드의 모임
- 실행문 : 작업을 지시하는 변수 선언, 값 저장, 메서드 호출 등의 코드
- 주석문 : 행 주석(//), 범위 주석(/*   \*/), 문서 주석(/**  */)

## 식별자
- 규칙
  - 문자, 언더바(_), $로 시작해야 한다. 한글도 가능하며, 영문자는 대·소문자를 구분한다.
  - +, - 등 연산자를 포함하면 안 된다.
  - 자바 키워드를 사용하면 안 된다.
  - 길이에 제한이 없다.
- 자바 키워드
  - 데이터 타입 : byte, char, short, int, long, float, double, boolean
  - 접근 지정자 : private, protected, public
  - 제어문 : if, else, for, while, do, break, continue, switch, case
  - 클래스와 객체 : class, interface, enum, extends, implements, new, this, super, instanceof, null
  - 예외 처리 : try, catch, finally, throw, throws
  - 기타 : abstract, assert, const, default, false, final, import, native, package, return, static, strictfp, synchronized, transient, true, void, volatile
- 관례
  - 변수와 메서드는 모두 소문자로 표기. 단, 복합 단어일 때는 두 번째 단어부터 단어의 첫 자만 대문자로 표기
  - 클래스와 인터페이스는 첫 자만 대문자로 표기하고 나머지는 소문자로 표기. 단, 복합 단어일 때는 두 번째 단어부터 단어의 첫 자만 대문자로 표기
  - 상수는 전체를 대문자로 표기. 단, 복합 단어일 때는 단어를 언더바(_)로 연결

## 데이터 타입 (크기, 기본값, 값의 범위)
- 정수
  - byte : 8비트, 0, -128 ~ 127
  - short : 16비트, 0, -32,768 ~ 32,767
  - int : 32비트, 0, -2,147,483,648 ~ 2,147,483,647
  - long : 64비트, 0L, -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
- 문자
  - char : 16비트, null, 0('\u0000') ~ 65,535('\uFFFF')
- 실수
  - float : 32비트, 0.0f, 약 -3.4E + 38 ~ 3.4E + 38
  - double : 64비트, 0.0d, 약 -1.7E + 308 ~ 1.7E + 308
- 논리
  - boolean : 8비트, false, true와 false

## 변수
- 의미
  - 프로그램은 기억 공간에 데이터를 보관하고, 각 기억 공간을 변수(Variable)로 구분
  - 변수는 데이터를 담는 상자와 같은 것으로 종류가 다양한데, 이를 구분하려고 데이터 타입을 사용
- 리터럴
  - 프로그램 내부에서 값을 정의해 변수를 초기화할 수 있는데, 그 값을 리터럴이라 한다.
- 사용
  - 선언
    ```java
    int weight; // 정수 타입의 weight라는 이름의 변수 선언
    double x, y, z; // 3개의 변수를 ,로 연결해 선언
    ```
  - 초기화
    ```java
    int weight = 50; // int형 weight 변수를 선언 후 50을 대입(선언과 동시에 초기화)
    weight = 30; // weight 변수에 30을 대입(선언 후 초기화)
    ```
- 상수
  - 프로그램 실행 중 변경할 수 없는 데이터를 담는 변수
    - 원주율 값(3.14159)이나 빛의 속도(3×108m/s) 등
  - 상수 이름은 변수와 구분하기 위해 모두 대문자로 표기
  - 반드시 final 키워드로 지정
    ```java
    final double PI = 3.14; // 상수 선언 및 초기화
    ```
- 타입 변환
  - 자동
    ```javas
    double d1 = 5 * 3.14; // 정수 5를 실수 5.0으로 자동 타입 변환
    double d2 = 1; // 정수 1을 실수 1.0으로 자동 타입 변환
    ```
  - 강제
    ```java
    float f = (float)3.14; // double의 3.14를 float로 강제 타입 변환 후 대입
    byte b = (byte)300; // int의 300을 byte로 강제 타입 변환시 데이터 손실 발생
    byte x = (byte)3.14; // double의 3.14를 byte로 강제 타입 변환시 데이터 손실되어 3만 대입
    ```
## 기본 입출력
- 화면에 데이터 출력
  - println() : () 내부의 내용을 출력한 후 행을 바꾼다.
  - print() : () 내부의 내용을 출력만 하고 행은 바꾸지 않는다.
  - printf() : 포맷을 지정해서 출력한다.
    - 정수 : %d(10진수), %o(8진수), %x(16진수), %c(문자), %5d(5자리, 빈자리는 공백 처리), %-5d(5자리, 빈자리는 공백 처리, 왼쪽 정렬), %05d(5자리, 빈자리는 0으로 채운다)
    - 문자열 : %s(문자열), %5s(5자리, 빈자리는 공백 처리), %-5s(5자리, 빈자리는 공백 처리, 왼쪽 정렬)
    - 실수 : %f(10진수), %e(지수), %4.1f(4자리, 소수점 이하 1자리), %-4.1f(4자리, 소수점 이하 1자리, 왼쪽 정렬), %04.1f(4자리, 소수점 이하 1자리, 빈자리는 0으로 채운다)
    ```java
    // 기본 형식
    // System.out.printf("포맷 명시자", 데이터, 데이터, ...);

    int x = 5;
    double pi = 3.14;

    System.out.printf("x = %d and pi = %f\n", x, pi); // %d와 %f는 포맷 명시자이며, 각각 x와 pi가 대응된다.
    ```
- 키보드로 데이터 입력
  - 프로그램의 첫 행에 다음을 추가해 Scanner 클래스의 경로 이름을 컴파일러에 알린다.
    ```java
    import java.util.Scanner;
    ```
  - 키보드로 데이터를 입력받으려고 System.in 객체와 연결된 Scanner 객체를 생성한다.
    ```java
    Scanner in = new Scanner(System.in);
    ```
  - Scanner 클래스가 제공하는 다양한 메서드를 이용해 키보드로 데이터를 입력받는다.
    ```java
    int x = in.nextInt(); // 정수를 읽어 변수 x에 대입한다.
    ```
  - Scanner 클래스가 제공하는 데이터 입력 메서드
    - next() : String 타입
    - nextByte() :  byte타입
    - nextShort() :  short타입
    - nextInt() :  int타입
    - nextLong() :  long타입
    - nextFloat() :  float타입
    - nextDouble() :  double타입
    - nextLine() : String 타입

## 연산자
- x + y 에서 x, y는 피연산자 +는 연산자를 의미
- 자바 가상 머신은 기본적으로 32비트 단위로 계산
  ```java
  byte b1 = 1;
  byte b2 = 2;
  byte b3 = b1 + b2; // 오류 발생
  ```
- 종류
  - 증감 : ++, -- (1만큼 증가 또는 감소) / 단항
  - 산술 : +, -, *, /, % (사칙 연산과 모듈로 연산) / 이항
  - 시프트 : >>, <<, >>> (비트를 좌우로 이동) / 이항
  - 부호 +, - (부호를 변환) / 단항
  - 비교 : >, <, >=, <=, ==, !=, instanceof (데이터 값을 비교하거나 데이터 타입을 비교) / 이항
  - 비트 : &, |, ~, ^ (비트 단위의 AND, OR, NOT, XOR) / 단항, 이항
  - 논리 : &&, ||, !, ^ (논리적 AND, OR, NOT, XOR) / 단항, 이항
  - 조건 : (expr) ? x : y (expr에 따라 x또는 y로 값을 결정) / 삼항
  - 대입 : =, +=, -=, *=, /=, &=, |=, ^=, >>=, <<=, >>>= (오른쪽 값을 연산해 왼쪽에 대입) / 이항
- 산술 연산자
  - 연산할 두 피연산자의 데이터 타입이 다르면 큰 범위의 타입으로 일치시킨 후 연산 수행
  - 논리 타입을 제외한 기초 타입을 피연산자로 사용. 단, % 연산자는 정수 타입만 사용
  - 덧셈 연산자는 문자열을 연결하는 데도 사용. 문자열과 덧셈을 하는 데이터는 먼저 문자열로 변환한 후 서로 연결
- 비교 연산자
  - 비교 연산자는 논리 타입을 제외한 기초 타입에만 사용할 수 있지만 ==와 !=는 모든 기초 타입에 사용
    ```
    x == y // x와 y는 같은가?
    x != y // x와 y가 다른가?
    x > y // x는 y보다 큰가?
    x >= y // x는 y보다 크거나 같은가?
    x < y // x는 y보다 작은가?
    x <= y // x는 y보다 작거나 같은가?
    ```
- 논리 연산자
  - 논리 연산자는 피연산자의 조건을 결합해서 true와 false를 조사하며, 논리 타입에만 사용
    ```java
    // !a는 true, a && b는 false, a || b는 false, a ^ b는 false
    a = false;
    b = false;
    
    // !a는 true, a && b는 false, a || b는 true, a ^ b는 true
    a = false;
    b = true;
    
    // !a는 false, a && b는 false, a || b는 true, a ^ b는 true
    a = true;
    b = false;
    
    // !a는 false, a && b는 true, a || b는 true, a ^ b는 false
    a = true;
    b = true;
    ```
  - &&, ||는 연산자의 앞 조건식의 결과에 따라 뒤 조건식의 실행 여부를 결정하며, 이를 쇼트서킷이라 한다.
- 비트, 시프트 연산자
  - 비트 연산자와 시프트 연산자는 정수 타입에만 사용
  - 종류
    - & : 두 비트가 모두 1일 때만 1이며, 나머지는 모두 0이다.
    - | : 두 비트가 모두 0일 때만 0이며, 나머지는 모두 1이다.
    - ^ : 두 비트가 서로 다를 때는 1, 동일할 때는 0이다.
    - ~ : 1을 0으로, 0을 1로 바꾼다.
    ```java
    System.out.printf("%x\n", 0b0101 & 0b0011); // 1
    System.out.printf("%x\n", 0b0101 | 0b0011); // 7
    System.out.printf("%x\n", 0b0101 ^ 0b0011); // 6
    System.out.printf("%x\n", (byte) ~0b00000001); // fe
    System.out.printf("%x\n", 0b0110 >> 2); // 1
    System.out.printf("%x\n", 0b0110 << 2); // 18

    int i1 = -10;
    int i2 = i1 >> 1;
    int i3 = i1 >>> 1;
    System.out.printf("%x -> %d\n", i1, i1); // ffffff6 -> -10
    System.out.printf("%x -> %d\n", i2, i2); // ffffffb -> -5
    System.out.printf("%x -> %d\n", i3, i3); // ffffffb -> 2147483643
    ```
- 대입 연산자
  - 오른쪽에 있는 연산식의 결과 값을 왼쪽에 있는 변수에 대입
    ```java
    int weight = 50;
    weight = weight + 10;
    ```
  - 복합 대입 연산자의 종류
    ```java
    a += b // a = a + b와 동일
    a -= b // a = a - b와 동일
    a *= b // a = a * b와 동일
    a /= b // a = a / b와 동일
    a %= b // a = a % b와 동일
    a &= b // a = a & b와 동일
    a |= b // a = a | b와 동일
    a ^= b // a = a ^ b와 동일
    a >>= b // a = a >> b와 동일
    a <<= b // a = a << b와 동일
    ```
  - 부호, 증감 연산자
    - 숫자를 나타내는 기초 타입에 사용하며 피연산자의 부호를 그대로 유지하거나 반전
    - 증감 연산자는 변수의 위치에 따라 의미가 다르다.
    - 종류
      - \+ : 부호 유지
      - \- : 부호 반전
      ```java
      ++x // 연산 전 x 값 중가(전위 증가)
      x++ // 연산 후 x 값 중가(후위 증가)
      --x // 연산 전 x 값 감소(전위 감소)
      x-- // 연산 후 x 값 감소(후위 감소)
      ```
  - 조건 연산자
    - 조건 연산자(?:)는 조건식이 true이면 결과 값은 앞 연산식의 값이 되고 false이면 결과 값은 뒤 연산식의 값이 된다.
    - 조건 연산자도 쇼트서킷 로직을 이용하기 때문에 조건식에 따라 앞 연산식과 뒤 연산식 중 하나만 실행
  - 우선 순위
    - [], ., (), ++, -- : 배열 접근, 객체 접근, 메서드 호출, 후위 증가, 후위 감소
    - +x, -x, ++x, --x, ~(비트), !(논리) : 부호 +/-, 선위 증가, 선위 감소, 비트 부정, 논리 부정
    - (), new : 타입 변환, 객체 생성
    - *, /, % : 곱셈, 나눗셈, 모듈로
    - +, - : 덧셈, 뺄셈
    - \>>, \<<, <<< : 시프트
    - \>, \<, >=, <=, instanceof : 비교
    - ==, != : 동등 여부
    - & : 비트 AND
    - ^ : 비트 XOR
    - | : 비트 OR
    - && : 조건 AND
    - || : 조건 OR
    - ?: : 조건 연산
    - =, +=, -=, *=, /=, &=, |=, ^=, >>=, <<=, >>>= : 대입
  - 결합 규칙
    ```java
    x = y = z = 3; // 3을 z, y, x 순으로 대입
    z = x * y / z % 2; // 연산자의 우선순위가 모두 같으므로 순서대로 연산
    z = x++ + --y * x // y에 1을 더한 후 x를 곱한 뒤 x를 더한 값을 대입해 준 뒤 x에 1을 더한다
    ```
    
## 제어문
제어문은 실행문의 수행 순서를 변경
- 종류  
  - 조건문 : 조건에 따라 실행문을 선택을 할 때 사용
    - 단순 if 문
      ```
      if(조건식)
      {
       실행문들;
      }
      ```
    - if~else 문
      ```
      if(조건식)
      {
       실행문들;
      }
      else
      {
       실행문들;
      }
      ```
    - 다중 if 문
      ```
      if(조건식)
      {
       실행문들;
      }
      else if(조건식)
      {
       실행문들;
      }
      else if(조건식)
      {
       ...
      }
      else
      {
       실행문들;
      }
      ```
    - 중첩 if 문
      ```
      // if 문에 다른 if 문이 포함되는 것을 중첩 if 문이라고 한다
      // else 문을 사용할때 주의 필요
      if(조건식)
      {
       if(조건식)
       {
        실행문들;
       }
      }
      ```
    - switch 문
      ```
      // 0개 이상의 case 절과 0이나 1개의 default 절로 구성
      switch(연산식)
      {
       case 값:
        실행문들;
       case 값:
        실행문들;
       ...
       default:
        실행문들;
      }
      ```
  - 반복문 : 조건에 따라 같은 처리를 반복
    - 반복할 조건을 아는 경우 while 문, do~while 문 사용
      - while 문
        ```
        // 조건문이 거짓인 경우에는 작동하지 않는다
        while(조건식)
        {
         반복 실행문들;
        }
        // 조건문이 항상 참인 경우 반복문을 탈출할 실행문 필요
        // 조건문이 항상 거짓인 경우 도달하지 않는 코드라는 오류 발생
        ```
      - do~while 문
        ```
        // 조건문이 거짓인 경우에도 한번은 작동한다
        do
        {
         반복 실행문들;
        } while(조건식);
        ```
    - 반복할 횟수를 아는 경우 for 문 사용
      - for문
        ```
        // 조건문이 거짓인 경우 실행문과 증감식이 작동하지 않는다
        // 초기식, 조건식, 증감식에 아무것도 넣지 않은 경우 무한반복
        for(초기식; 조건식; 증감식)
        {
         반복 실행문들;
        }
        ```
        ```java
        for(int i = 0; i < 2; i ++)
        {
         System.out.println(i); // 0, 1을 출력한다
        }
        ```
  - 분기문
    - break 문
      ```
      while(조건식)
      {
       while(조건식)
       {
        break; // 가장 안쪽의 while 문 만 탈출한다
       }
      }
      
      out : while(조건식)
      {
       while(조건식)
       {
        break out; // out 레이블의 while 문을 탈출한다
       }
      }
      ```
    - continue 문
      ```
      while(조건식)
      {
       continue; // continue 다음의 실행문들을 건너뛴다
      }
      ```
  - 메서드
    - 필요성
      - 중복 코드를 줄이고 코드를 재사용할 수 있다
      - 코드를 모듈화해 가독성을 높이므로 프로그램의 품질을 향상시킨다
    - 구조
      ```java
      // public : 접근 지정자
      // static : 객체를 생성하지 않고 실행할 수 있다
      // int : 반환 타입
      // sum : 메서드 이름
      // int i1, int i2 : 매개변수 목록
      public static int sum(int i1, int i2)
      {
       return i1 + i2; // i1 + i2의 타입과 반환 타입이 일치해야 한다.
      }
      ```
    - 메서드의 호출과 반환
      - 메서드를 호출하면 제어가 호출된 메서드(callee)로 넘어갔다가 실행을 마친 후 호출한 메서드(caller)로 다시 돌아온다.
      - return 문을 사용하면 메서드의 실행 도중에도 호출한 메서드로 제어를 넘길 수 있다.
    - 값 전달
      ```java
      int x = 0;
      increment(x);

      public static void increment(int n)
      {
       n++;
      }
      // increment() 메서드 호출 전 x는 0
      // increment() 메서드 시작할 때 n은 0
      // increment() 메서드 끝날 때 n은 1
      // increment() 메서드 호출 후 x는 0
      ```
    - 메서드 오버로딩
      - 메서드 시그너처(Method Signature) : 메서드 이름과 매개변수의 개수, 데이터 타입, 순서를 의미
      - 메서드 이름은 같지만 메서드 시그니처가 다른 메서드를 정의하는 것을 메서드 오버로딩(Method Overloading)이라고 한다.

## 객체 지향
- 객체의 개념
  - 소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것
  - 소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의.
  - 필드는 객체 내부에 선언된 변수를 의미하고, 메서드는 객체 내부에 정의된 동작
- 절차 지향 프로그래밍
  - 일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열
  - 데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점
  - 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래밍과 이해하기가 용이
  - 소프트웨어는 계산 위주이므로 절차 지향 프로그래밍이 적합
- 객체 지향 프로그래밍
  - 프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것
  - 현실 세계를 객체 단위로 프로그래밍하며, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현
- 특징
  - 캡슐화(정보 은닉) : 관련된 필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것
  - 상속 : 자녀가 부모 재산을 상속받아 사용하듯이 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것
  - 다형성 : 대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현, 실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 가능

## 클래스 선언과 객체 생성
- 추상화
  - 현실 세계의 객체는 수많은 상태가 있고 다양한 동작을 하지만, 클래스에 모두 포함하기는 어렵기에 추상화(Abstraction)하는 과정이 필요
  - 추상화는 현실 세계의 객체에서 불필요한 속성을 제거하고 중요한 정보만 클래스로 표현하는 일종의 모델링 기법
  - 사람마다 추상화하는 기법이 같지 않으므로 각 개발자는 클래스를 다르게 정의 가능
- 클래스 선언
  ```java
  // class : 클래스 키워드
  // ReturnN : 클래스 이름으로 소스 파일 이름과 동일해야 한다
  // 필드 : 객체의 속성을 나타낸다
  // 메서드 : 객체의 동작을 나타낸다
  public class ReturnN
  {
    int n = 0; // 필드
  
    int getN() // 메서드
    {
      return n;
    }
  }
  ```
  - 보통 소스 파일마다 하나의 클래스를 선언하지만, 2개 이상의 클래스를 하나의 파일로 선언 가능
  - 하나의 파일에 클래스가 둘 이상 있다면 하나만 public으로 선언할 수 있고, 해당 클래스 이름은 소스 파일 이름과 동일해야 함
- 객체 생성과 참조 변수
  ```
  클래스이름 변수; // 클래스는 참조 타입이므로 참조 변수 또는 참조 타입 변수라고 한다
  변수 = new 클래스이름(); // 클래스이름()을 생성자라고 한다
  // 변수를 생략하거나 한 문장으로 변수 선언과 객체 생성 또한 가능하다
  ```

## 클래스의 구성 요소와 멤버 접근
- 클래스의 구성 요소
  - 멤버(필드, 메서드)
  - 생성자
  > 지역 변수는 메서드 내부에 선언된 변수. 매개 변수도 일종의 지역 변수이다
- 필드와 지역 변수의 차이
  - 필드는 기본 값이 있지만, 지역 변수는 기본 값이 없어 반드시 초기화
  - 필드는 클래스 전체에서 사용할 수 있지만, 지역 변수는 선언된 블록 내부의 선언된 후에서만 사용 가능
  - 필드와 달리 지역 변수는 final로만 지정 가능
- 클래스 내부에서 멤버 접근
  ```
  this.필드 // 또는 필드로 사용
  this.메서드 // 또는 메서드로 사용
  ```
- 클래스 외부에서 멤버 접근
  ```java
  // myCircle : 사용하려는 외부 객체 이름
  // . : 객체와 객체 멤버를 연결하는 연산자
  // radius : 필드 이름
  // findArea : 메서드 이름
  myCircle.radius; // 인스턴스 변수
  myCircle.findArea(); // 인스턴스 메서드
  ```

## 접근자와 설정자
- 필요성
  클래스 내부에 캡슐화된 멤버를 외부에서 사용하기 위해
- 접근자와 설정자
  - private으로 지정된 필드에 값을 반환하는 접근자와 값을 변경하는 설정자는 공개된 메서드
  - 일반적으로 접근자는 get, 설정자는 set으로 시작하는 이름을 사용
  - 필드 이름을 외부와 차단해서 독립시키기 때문에 필드 이름 변경이나 데이터 검증도 가능

## 생성자
- 생성자의 의미와 선언
  - 생성자의 역할 : 객체를 생성하는 시점에서 필드를 다양하게 초기화
  - 생성자의 선언 방식
    ```
    클래스이름(...) {...} // 일반적으로 public으로 선언하지만 아닐 수도 있다
    ```
    - 생성자 이름은 클래스 이름과 같다.
    - 생성자의 반환 타입은 없다.
    - 생성자는 new 연산자와 함께 사용하며, 객체를 생성할 때 호출한다.
    - 생성자도 오버로딩할 수 있다
  - 생성자 사용
    ```
    클래스이름 변수 = new 클래스이름(); // 클래스이름()을 생성자라고 한다
    ```
- 기본 생성자
  - 모든 클래스는 최소한 하나의 생성자가 있음
  - 만약 생성자를 선언하지 않으면 컴파일러가 자동으로 기본 생성자(Default Constructor)를 추가
  - 기본 생성자는 매개변수도 없고 본체에서 실행할 내용도 없는 생성자
- 생성자 오버로딩
  생성자도 메서드처럼 오버로딩(Overloading) 가능
- this와 this()
  ```java
  // this
  class Square
  {
    private double side; // 멤버 필드

    public void setRadius(double side)
    {
      this.side = side; // 매개변수 = 멤버 필드의 형식이다
    }
  }
  
  // this()
  class Circle
  {
    private double radius; // 멤버 필드

    public Circle(double radius)
    {
      this.radius = radius; // 매개변수 = 멤버 필드의 형식이다
    }

    public Circle()
    {
      this(2.0); // 같은 클래스의 다른 Circle() 생성자를 호출해 매개변수로 2.0을 넣는다
    }
  }
  ```
- 연속 호출
  반환 타입이 void인 setName(String name), setAge(), sayHello()라는 메서드를 가진 Person 클래스가 있다고 가정
    ```java
    Person person = new Person();
    person.setName("민국");
    person.setAge(21);
    person.sayHello();
    // 메서드를 호출할 때마다 새로운 실행문을 사용해야 하므로 번거롭고 가독성도 떨어진다
    ```
  setName()과 setAge()의 반환 타입이 this라면
    ```java
    Person person = new Person();
    person.setName("민국").setAge(21).sayHello(); // 한번에 호출이 가능하다
    ```

## 정적 멤버
- 인스턴스 멤버와 정적 멤버
  - 자바는 static 키워드로 클래스의 필드를 공유할 수 있도록 지원
  - 인스턴스 변수 : static 키워드로 지정되지 않아 공유되지 않은 필드로 인스턴스마다 자신의 필드를 생성
  - 정적 변수 혹은 클래스 변수 : static 키워드로 지정하여 모든 인스턴스가 공유하는 필드
  - 인스턴스 변수는 객체별로 관리. 객체를 생성할 때 인스턴스 변수도 객체가 소멸될 때는 자동으로 소멸
  - 정적 변수는 클래스 로더가 클래스를 메서드 영역에 적재할 때 생성
  - 정적 메서드의 유의 사항
    - 객체와 관련된 인스턴스 변수를 사용할 수 없다.
    - 객체와 관련된 인스턴스 메서드를 호출할 수 없다.
    - 객체 자신을 가리키는 this 키워드를 사용할 수 없다.
- 정적 멤버의 활용
  ```
  // 정적 멤버는 일반적으로 클래스 이름과 연결해서 사용한다
  클래스이름.정적변수이름;
  클래스이름.정적메서드이름();
  ```
  - 상수는 변경되지 않는 변수이기 때문에 final 키워드로 지정하지만 final로만 지정하면 객체마다 자신의 기억 공간을 차지
  - 상수는 값이 변경되지 않으므로 객체마다 따로 기억 공간을 할당할 필요가 없다. 따라서 static final로 지정해서 선언
  ```
  // static : 모든 객체가 공유한다
  // final : 초깃값이 대입되면 더 이상 수정할 수 없다
  static final 데이터형 상수 = 초깃값;
  ```
- 정적 블록
  정적 변수의 초기화 과정이 for 문이나 오류 처리처럼 복잡하다면 과정이 간단하지 않다. 대신에 정적 변수의 초기화가 복잡할 때는 다음과 같이 정적 블록을 사용할 수 있다.
  ```
  static String name = "민국";
  static
  {
    name = "만국";
  }
  // name을 호출할 경우 "만국"이 호출된다
  ```


